#!/usr/bin/env python3
import argparse
import json
import os
import re
import subprocess
import sys
from pathlib import Path
from typing import List, Optional, Tuple


def run_cmd(cmd: List[str], log_path: Path, env: Optional[dict] = None) -> int:
    log_path.parent.mkdir(parents=True, exist_ok=True)
    with log_path.open("w", encoding="utf-8") as f:
        f.write("CMD:\n")
        f.write(" ".join(cmd) + "\n\n")
        p = subprocess.run(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            env=env,
        )
        f.write(p.stdout or "")
        f.write(f"\n\nEXIT_CODE={p.returncode}\n")
    return p.returncode


def get_help(script_path: Path) -> str:
    p = subprocess.run(
        [sys.executable, str(script_path), "--help"],
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
    )
    return p.stdout or ""


def detect_subcommands(help_text: str) -> List[str]:
    # Essaie de récupérer un truc du style: usage: run_sost.py [-h] {run,foo,bar} ...
    m = re.search(r"\{([^}]+)\}", help_text)
    if not m:
        return []
    raw = m.group(1)
    parts = [p.strip() for p in raw.split(",")]
    return [p for p in parts if p]


def pick_flag(help_text: str, candidates: List[str]) -> Optional[str]:
    for c in candidates:
        if c in help_text:
            return c
    return None


def output_expects_file(help_text: str, out_flag: str) -> bool:
    # Heuristique:
    # - si le flag contient "dir" => dossier
    # - sinon si la ligne d'aide parle de json / file => fichier
    lf = out_flag.lower()
    if "dir" in lf or "folder" in lf:
        return False
    for line in help_text.splitlines():
        if out_flag in line:
            low = line.lower()
            if "json" in low or "file" in low or "fichier" in low:
                return True
    # fallback
    if out_flag in ["--out", "--output"]:
        return True
    return False


def build_attempts(
    script_path: Path,
    csv_path: Path,
    out_band_dir: Path,
    help_text: str,
) -> List[List[str]]:
    # Détection flags possibles
    input_flag = pick_flag(
        help_text,
        [
            "--input",
            "--input-csv",
            "--input_csv",
            "--csv",
            "--csv-path",
            "--csv_path",
            "--path",
        ],
    )

    out_flag = pick_flag(
        help_text,
        [
            "--outdir",
            "--out-dir",
            "--out_dir",
            "--output-dir",
            "--output_dir",
            "--output",
            "--out",
        ],
    )

    # Détection sous-commande
    subs = detect_subcommands(help_text)
    # on privilégie "run" si existe
    subcmds_to_try: List[Optional[str]] = [None]
    if subs:
        if "run" in subs:
            subcmds_to_try = ["run", None]
        else:
            subcmds_to_try = [subs[0], None]

    attempts: List[List[str]] = []

    def mk_cmd(subcmd: Optional[str], use_input_flag: bool, use_out: bool) -> List[str]:
        cmd = [sys.executable, str(script_path)]
        if subcmd:
            cmd.append(subcmd)

        if use_input_flag and input_flag:
            cmd += [input_flag, str(csv_path)]
        else:
            cmd.append(str(csv_path))

        if use_out and out_flag:
            expects_file = output_expects_file(help_text, out_flag)
            if expects_file:
                out_file = out_band_dir / "sost_out.json"
                cmd += [out_flag, str(out_file)]
            else:
                cmd += [out_flag, str(out_band_dir)]

        return cmd

    # Combinaisons en cascade
    for subcmd in subcmds_to_try:
        if input_flag:
            attempts.append(mk_cmd(subcmd, use_input_flag=True, use_out=True))
            attempts.append(mk_cmd(subcmd, use_input_flag=True, use_out=False))
        attempts.append(mk_cmd(subcmd, use_input_flag=False, use_out=True))
        attempts.append(mk_cmd(subcmd, use_input_flag=False, use_out=False))

    # Fallbacks “hardcodés” (au cas où l'aide est minimale)
    hard_inputs = [
        ["--input", str(csv_path)],
        ["--input-csv", str(csv_path)],
        ["--input_csv", str(csv_path)],
    ]
    hard_outs = [
        ["--outdir", str(out_band_dir)],
        ["--out_dir", str(out_band_dir)],
        ["--out", str(out_band_dir / "sost_out.json")],
        ["--output", str(out_band_dir / "sost_out.json")],
    ]
    for subcmd in subcmds_to_try:
        base = [sys.executable, str(script_path)] + ([subcmd] if subcmd else [])
        for hi in hard_inputs:
            for ho in hard_outs:
                attempts.append(base + hi + ho)
            attempts.append(base + hi)
        # positional
        for ho in hard_outs:
            attempts.append(base + [str(csv_path)] + ho)
        attempts.append(base + [str(csv_path)])

    # Dédupe
    uniq = []
    seen = set()
    for a in attempts:
        k = tuple(a)
        if k not in seen:
            seen.add(k)
            uniq.append(a)
    return uniq


def find_run_sost(repo_root: Path) -> Path:
    candidates = [
        repo_root / "scripts" / "run_sost.py",
        repo_root / "run_sost.py",
    ]
    for c in candidates:
        if c.exists():
            return c
    raise FileNotFoundError("Impossible de trouver run_sost.py (attendu scripts/run_sost.py ou ./run_sost.py)")


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--pattern", default="test_data/band_*.csv")
    ap.add_argument("--outdir", default="_ci_out/bands")
    args = ap.parse_args()

    repo_root = Path(".").resolve()
    out_root = Path(args.outdir).resolve()
    out_root.mkdir(parents=True, exist_ok=True)

    run_sost = find_run_sost(repo_root)
    help_text = get_help(run_sost)

    (out_root.parent / "run_sost_help.txt").write_text(help_text, encoding="utf-8")

    csvs = sorted(Path(".").glob(args.pattern))
    if not csvs:
        print(f"Aucun CSV trouvé avec pattern: {args.pattern}")
        return 2

    env = os.environ.copy()
    env["PYTHONPATH"] = "."

    results = []
    ok_count = 0

    for csv_path in csvs:
        stem = csv_path.stem
        out_band_dir = out_root / stem
        out_band_dir.mkdir(parents=True, exist_ok=True)

        log_path = out_band_dir / "run.log"

        attempts = build_attempts(run_sost, csv_path, out_band_dir, help_text)

        final_rc = None
        final_cmd = None

        for i, cmd in enumerate(attempts, start=1):
            rc = run_cmd(cmd, log_path, env=env)

            # code 2: usage/argparse, on continue à essayer d'autres formes
            if rc == 2:
                continue

            final_rc = rc
            final_cmd = cmd
            break

        if final_rc is None:
            # On n'a obtenu que des "usage errors"
            final_rc = 2
            final_cmd = attempts[-1] if attempts else [sys.executable, str(run_sost)]

        success = (final_rc == 0)
        if success:
            ok_count += 1

        results.append(
            {
                "band": stem,
                "csv": str(csv_path),
                "success": success,
                "exit_code": final_rc,
                "cmd": " ".join(final_cmd) if final_cmd else None,
                "log": str(log_path),
            }
        )

    summary = {
        "total": len(results),
        "ok": ok_count,
        "fail": len(results) - ok_count,
        "pattern": args.pattern,
        "outdir": str(out_root),
        "results": results,
    }

    (out_root.parent / "band_suite_summary.json").write_text(
        json.dumps(summary, indent=2, ensure_ascii=False),
        encoding="utf-8",
    )

    print(f"Bands OK: {ok_count} / {len(results)}")
    # On veut que la CI échoue si tout est cassé
    return 0 if ok_count == len(results) else 1


if __name__ == "__main__":
    raise SystemExit(main())
